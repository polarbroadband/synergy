// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package monsoon

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// ControllerClient is the client API for Controller service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ControllerClient interface {
	// healthckeck
	Healtz(ctx context.Context, in *Request, opts ...grpc.CallOption) (*SvrStat, error)
	// request to create runner
	CreateRunner(ctx context.Context, in *RunnerRequest, opts ...grpc.CallOption) (*SvcStat, error)
	ConnectRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (Controller_ConnectRunnerClient, error)
	JoinRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (Controller_JoinRunnerClient, error)
	StartRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (*OprStat, error)
	StopRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (*OprStat, error)
	UpdateRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (*OprStat, error)
	// worker regist
	RegistWorker(ctx context.Context, in *SvrStat, opts ...grpc.CallOption) (*OprStat, error)
}

type controllerClient struct {
	cc grpc.ClientConnInterface
}

func NewControllerClient(cc grpc.ClientConnInterface) ControllerClient {
	return &controllerClient{cc}
}

func (c *controllerClient) Healtz(ctx context.Context, in *Request, opts ...grpc.CallOption) (*SvrStat, error) {
	out := new(SvrStat)
	err := c.cc.Invoke(ctx, "/monsoon.Controller/Healtz", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) CreateRunner(ctx context.Context, in *RunnerRequest, opts ...grpc.CallOption) (*SvcStat, error) {
	out := new(SvcStat)
	err := c.cc.Invoke(ctx, "/monsoon.Controller/CreateRunner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) ConnectRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (Controller_ConnectRunnerClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Controller_serviceDesc.Streams[0], "/monsoon.Controller/ConnectRunner", opts...)
	if err != nil {
		return nil, err
	}
	x := &controllerConnectRunnerClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Controller_ConnectRunnerClient interface {
	Recv() (*RunnerOutput, error)
	grpc.ClientStream
}

type controllerConnectRunnerClient struct {
	grpc.ClientStream
}

func (x *controllerConnectRunnerClient) Recv() (*RunnerOutput, error) {
	m := new(RunnerOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controllerClient) JoinRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (Controller_JoinRunnerClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Controller_serviceDesc.Streams[1], "/monsoon.Controller/JoinRunner", opts...)
	if err != nil {
		return nil, err
	}
	x := &controllerJoinRunnerClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Controller_JoinRunnerClient interface {
	Recv() (*RunnerOutput, error)
	grpc.ClientStream
}

type controllerJoinRunnerClient struct {
	grpc.ClientStream
}

func (x *controllerJoinRunnerClient) Recv() (*RunnerOutput, error) {
	m := new(RunnerOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *controllerClient) StartRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (*OprStat, error) {
	out := new(OprStat)
	err := c.cc.Invoke(ctx, "/monsoon.Controller/StartRunner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) StopRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (*OprStat, error) {
	out := new(OprStat)
	err := c.cc.Invoke(ctx, "/monsoon.Controller/StopRunner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) UpdateRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (*OprStat, error) {
	out := new(OprStat)
	err := c.cc.Invoke(ctx, "/monsoon.Controller/UpdateRunner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) RegistWorker(ctx context.Context, in *SvrStat, opts ...grpc.CallOption) (*OprStat, error) {
	out := new(OprStat)
	err := c.cc.Invoke(ctx, "/monsoon.Controller/RegistWorker", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControllerServer is the server API for Controller service.
// All implementations must embed UnimplementedControllerServer
// for forward compatibility
type ControllerServer interface {
	// healthckeck
	Healtz(context.Context, *Request) (*SvrStat, error)
	// request to create runner
	CreateRunner(context.Context, *RunnerRequest) (*SvcStat, error)
	ConnectRunner(*RunnerUpdate, Controller_ConnectRunnerServer) error
	JoinRunner(*RunnerUpdate, Controller_JoinRunnerServer) error
	StartRunner(context.Context, *RunnerUpdate) (*OprStat, error)
	StopRunner(context.Context, *RunnerUpdate) (*OprStat, error)
	UpdateRunner(context.Context, *RunnerUpdate) (*OprStat, error)
	// worker regist
	RegistWorker(context.Context, *SvrStat) (*OprStat, error)
	mustEmbedUnimplementedControllerServer()
}

// UnimplementedControllerServer must be embedded to have forward compatible implementations.
type UnimplementedControllerServer struct {
}

func (UnimplementedControllerServer) Healtz(context.Context, *Request) (*SvrStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Healtz not implemented")
}
func (UnimplementedControllerServer) CreateRunner(context.Context, *RunnerRequest) (*SvcStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRunner not implemented")
}
func (UnimplementedControllerServer) ConnectRunner(*RunnerUpdate, Controller_ConnectRunnerServer) error {
	return status.Errorf(codes.Unimplemented, "method ConnectRunner not implemented")
}
func (UnimplementedControllerServer) JoinRunner(*RunnerUpdate, Controller_JoinRunnerServer) error {
	return status.Errorf(codes.Unimplemented, "method JoinRunner not implemented")
}
func (UnimplementedControllerServer) StartRunner(context.Context, *RunnerUpdate) (*OprStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartRunner not implemented")
}
func (UnimplementedControllerServer) StopRunner(context.Context, *RunnerUpdate) (*OprStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopRunner not implemented")
}
func (UnimplementedControllerServer) UpdateRunner(context.Context, *RunnerUpdate) (*OprStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRunner not implemented")
}
func (UnimplementedControllerServer) RegistWorker(context.Context, *SvrStat) (*OprStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegistWorker not implemented")
}
func (UnimplementedControllerServer) mustEmbedUnimplementedControllerServer() {}

// UnsafeControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ControllerServer will
// result in compilation errors.
type UnsafeControllerServer interface {
	mustEmbedUnimplementedControllerServer()
}

func RegisterControllerServer(s grpc.ServiceRegistrar, srv ControllerServer) {
	s.RegisterService(&_Controller_serviceDesc, srv)
}

func _Controller_Healtz_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).Healtz(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monsoon.Controller/Healtz",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).Healtz(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_CreateRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).CreateRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monsoon.Controller/CreateRunner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).CreateRunner(ctx, req.(*RunnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_ConnectRunner_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunnerUpdate)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ControllerServer).ConnectRunner(m, &controllerConnectRunnerServer{stream})
}

type Controller_ConnectRunnerServer interface {
	Send(*RunnerOutput) error
	grpc.ServerStream
}

type controllerConnectRunnerServer struct {
	grpc.ServerStream
}

func (x *controllerConnectRunnerServer) Send(m *RunnerOutput) error {
	return x.ServerStream.SendMsg(m)
}

func _Controller_JoinRunner_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunnerUpdate)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ControllerServer).JoinRunner(m, &controllerJoinRunnerServer{stream})
}

type Controller_JoinRunnerServer interface {
	Send(*RunnerOutput) error
	grpc.ServerStream
}

type controllerJoinRunnerServer struct {
	grpc.ServerStream
}

func (x *controllerJoinRunnerServer) Send(m *RunnerOutput) error {
	return x.ServerStream.SendMsg(m)
}

func _Controller_StartRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunnerUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).StartRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monsoon.Controller/StartRunner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).StartRunner(ctx, req.(*RunnerUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_StopRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunnerUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).StopRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monsoon.Controller/StopRunner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).StopRunner(ctx, req.(*RunnerUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_UpdateRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunnerUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).UpdateRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monsoon.Controller/UpdateRunner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).UpdateRunner(ctx, req.(*RunnerUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_RegistWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SvrStat)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).RegistWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monsoon.Controller/RegistWorker",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).RegistWorker(ctx, req.(*SvrStat))
	}
	return interceptor(ctx, in, info, handler)
}

var _Controller_serviceDesc = grpc.ServiceDesc{
	ServiceName: "monsoon.Controller",
	HandlerType: (*ControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Healtz",
			Handler:    _Controller_Healtz_Handler,
		},
		{
			MethodName: "CreateRunner",
			Handler:    _Controller_CreateRunner_Handler,
		},
		{
			MethodName: "StartRunner",
			Handler:    _Controller_StartRunner_Handler,
		},
		{
			MethodName: "StopRunner",
			Handler:    _Controller_StopRunner_Handler,
		},
		{
			MethodName: "UpdateRunner",
			Handler:    _Controller_UpdateRunner_Handler,
		},
		{
			MethodName: "RegistWorker",
			Handler:    _Controller_RegistWorker_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ConnectRunner",
			Handler:       _Controller_ConnectRunner_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "JoinRunner",
			Handler:       _Controller_JoinRunner_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "monsoon.proto",
}

// WorkerClient is the client API for Worker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkerClient interface {
	// worker healthckeck
	Healtz(ctx context.Context, in *Request, opts ...grpc.CallOption) (*SvrStat, error)
	// runner healthckeck
	RunnerHealtz(ctx context.Context, in *RunnerRequest, opts ...grpc.CallOption) (*SvcStat, error)
	// request to create runner
	CreateRunner(ctx context.Context, in *RunnerRequest, opts ...grpc.CallOption) (*SvcStat, error)
	ConnectRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (Worker_ConnectRunnerClient, error)
	StartRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (*OprStat, error)
	StopRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (*OprStat, error)
	UpdateRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (*OprStat, error)
}

type workerClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkerClient(cc grpc.ClientConnInterface) WorkerClient {
	return &workerClient{cc}
}

func (c *workerClient) Healtz(ctx context.Context, in *Request, opts ...grpc.CallOption) (*SvrStat, error) {
	out := new(SvrStat)
	err := c.cc.Invoke(ctx, "/monsoon.Worker/Healtz", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) RunnerHealtz(ctx context.Context, in *RunnerRequest, opts ...grpc.CallOption) (*SvcStat, error) {
	out := new(SvcStat)
	err := c.cc.Invoke(ctx, "/monsoon.Worker/RunnerHealtz", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) CreateRunner(ctx context.Context, in *RunnerRequest, opts ...grpc.CallOption) (*SvcStat, error) {
	out := new(SvcStat)
	err := c.cc.Invoke(ctx, "/monsoon.Worker/CreateRunner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) ConnectRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (Worker_ConnectRunnerClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Worker_serviceDesc.Streams[0], "/monsoon.Worker/ConnectRunner", opts...)
	if err != nil {
		return nil, err
	}
	x := &workerConnectRunnerClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Worker_ConnectRunnerClient interface {
	Recv() (*RunnerOutput, error)
	grpc.ClientStream
}

type workerConnectRunnerClient struct {
	grpc.ClientStream
}

func (x *workerConnectRunnerClient) Recv() (*RunnerOutput, error) {
	m := new(RunnerOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workerClient) StartRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (*OprStat, error) {
	out := new(OprStat)
	err := c.cc.Invoke(ctx, "/monsoon.Worker/StartRunner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) StopRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (*OprStat, error) {
	out := new(OprStat)
	err := c.cc.Invoke(ctx, "/monsoon.Worker/StopRunner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerClient) UpdateRunner(ctx context.Context, in *RunnerUpdate, opts ...grpc.CallOption) (*OprStat, error) {
	out := new(OprStat)
	err := c.cc.Invoke(ctx, "/monsoon.Worker/UpdateRunner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerServer is the server API for Worker service.
// All implementations must embed UnimplementedWorkerServer
// for forward compatibility
type WorkerServer interface {
	// worker healthckeck
	Healtz(context.Context, *Request) (*SvrStat, error)
	// runner healthckeck
	RunnerHealtz(context.Context, *RunnerRequest) (*SvcStat, error)
	// request to create runner
	CreateRunner(context.Context, *RunnerRequest) (*SvcStat, error)
	ConnectRunner(*RunnerUpdate, Worker_ConnectRunnerServer) error
	StartRunner(context.Context, *RunnerUpdate) (*OprStat, error)
	StopRunner(context.Context, *RunnerUpdate) (*OprStat, error)
	UpdateRunner(context.Context, *RunnerUpdate) (*OprStat, error)
	mustEmbedUnimplementedWorkerServer()
}

// UnimplementedWorkerServer must be embedded to have forward compatible implementations.
type UnimplementedWorkerServer struct {
}

func (UnimplementedWorkerServer) Healtz(context.Context, *Request) (*SvrStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Healtz not implemented")
}
func (UnimplementedWorkerServer) RunnerHealtz(context.Context, *RunnerRequest) (*SvcStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunnerHealtz not implemented")
}
func (UnimplementedWorkerServer) CreateRunner(context.Context, *RunnerRequest) (*SvcStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRunner not implemented")
}
func (UnimplementedWorkerServer) ConnectRunner(*RunnerUpdate, Worker_ConnectRunnerServer) error {
	return status.Errorf(codes.Unimplemented, "method ConnectRunner not implemented")
}
func (UnimplementedWorkerServer) StartRunner(context.Context, *RunnerUpdate) (*OprStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartRunner not implemented")
}
func (UnimplementedWorkerServer) StopRunner(context.Context, *RunnerUpdate) (*OprStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopRunner not implemented")
}
func (UnimplementedWorkerServer) UpdateRunner(context.Context, *RunnerUpdate) (*OprStat, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRunner not implemented")
}
func (UnimplementedWorkerServer) mustEmbedUnimplementedWorkerServer() {}

// UnsafeWorkerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkerServer will
// result in compilation errors.
type UnsafeWorkerServer interface {
	mustEmbedUnimplementedWorkerServer()
}

func RegisterWorkerServer(s grpc.ServiceRegistrar, srv WorkerServer) {
	s.RegisterService(&_Worker_serviceDesc, srv)
}

func _Worker_Healtz_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).Healtz(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monsoon.Worker/Healtz",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).Healtz(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_RunnerHealtz_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).RunnerHealtz(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monsoon.Worker/RunnerHealtz",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).RunnerHealtz(ctx, req.(*RunnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_CreateRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunnerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).CreateRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monsoon.Worker/CreateRunner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).CreateRunner(ctx, req.(*RunnerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_ConnectRunner_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunnerUpdate)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkerServer).ConnectRunner(m, &workerConnectRunnerServer{stream})
}

type Worker_ConnectRunnerServer interface {
	Send(*RunnerOutput) error
	grpc.ServerStream
}

type workerConnectRunnerServer struct {
	grpc.ServerStream
}

func (x *workerConnectRunnerServer) Send(m *RunnerOutput) error {
	return x.ServerStream.SendMsg(m)
}

func _Worker_StartRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunnerUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).StartRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monsoon.Worker/StartRunner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).StartRunner(ctx, req.(*RunnerUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_StopRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunnerUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).StopRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monsoon.Worker/StopRunner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).StopRunner(ctx, req.(*RunnerUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Worker_UpdateRunner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunnerUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServer).UpdateRunner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/monsoon.Worker/UpdateRunner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServer).UpdateRunner(ctx, req.(*RunnerUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

var _Worker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "monsoon.Worker",
	HandlerType: (*WorkerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Healtz",
			Handler:    _Worker_Healtz_Handler,
		},
		{
			MethodName: "RunnerHealtz",
			Handler:    _Worker_RunnerHealtz_Handler,
		},
		{
			MethodName: "CreateRunner",
			Handler:    _Worker_CreateRunner_Handler,
		},
		{
			MethodName: "StartRunner",
			Handler:    _Worker_StartRunner_Handler,
		},
		{
			MethodName: "StopRunner",
			Handler:    _Worker_StopRunner_Handler,
		},
		{
			MethodName: "UpdateRunner",
			Handler:    _Worker_UpdateRunner_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ConnectRunner",
			Handler:       _Worker_ConnectRunner_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "monsoon.proto",
}
